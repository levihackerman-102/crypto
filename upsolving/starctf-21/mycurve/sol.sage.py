

# This file was *autogenerated* from the file sol.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_100 = Integer(100); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3)
def add(P,Q):
	if Q==_sage_const_0 :
		return P
	x1,y1=P
	x2,y2=Q
	x3=(d1*(x1+x2)+d2*(x1+y1)*(x2+y2)+(x1+x1**_sage_const_2 )*(x2*(y1+y2+_sage_const_1 )+y1*y2))/(d1+(x1+x1**_sage_const_2 )*(x2+y2))
	y3=(d1*(y1+y2)+d2*(x1+y1)*(x2+y2)+(y1+y1**_sage_const_2 )*(y2*(x1+x2+_sage_const_1 )+x1*x2))/(d1+(y1+y1**_sage_const_2 )*(x2+y2))
	return x3,y3

def mul(k,P):
	Q=_sage_const_0 
	while k>_sage_const_0 :
		if is_even(k):
			k/=_sage_const_2 
			P=add(P,P)
		else:
			k-=_sage_const_1 
			Q=add(P,Q)
	return Q

# Mapping (x,) -> (u,v) and (u,v) -> (x,y) for the birational equivalence between the Weierstrass and Binary Edwards 
def bined2w(P):
	x,y=P
	return (d1*(d1**_sage_const_2 +d1+d2)*(x+y)/(x*y+d1*(x+y)),d1*(d1**_sage_const_2 +d1+d2)*(x/(x*y+d1*(x+y))+d1+_sage_const_1 ))

def w2bined(P):
	u,v=P
	return (d1*(u+d1**_sage_const_2 +d1+d2)/(u+v+(d1**_sage_const_2 +d1)*(d1**_sage_const_2 +d1+d2)),d1*(u+d1**_sage_const_2 +d1+d2)/(v+(d1**_sage_const_2 +d1)*(d1**_sage_const_2 +d1+d2)))

F=GF(_sage_const_2 **_sage_const_100 )
R = F['x, y']; (x, y,) = R._first_ngens(2)
d1=F.fetch_int(_sage_const_1 )
d2=F.fetch_int(_sage_const_1 )
a2=d1**_sage_const_2 +d2
a6=d1**_sage_const_4 *(d1**_sage_const_4 +d1**_sage_const_2 +d2**_sage_const_2 )
E=EllipticCurve(y**_sage_const_2 +x*y-x**_sage_const_3 -a2*x**_sage_const_2 -a6)
factor(E.order())
x,y=(698546134536218110797266045394 , 1234575357354908313123830206394 )
G=(F.fetch_int(x),F.fetch_int(y))
x,y=(403494114976379491717836688842 , 915160228101530700618267188624 )
P=(F.fetch_int(x),F.fetch_int(y))
P=E(bined2w(P))
G=E(bined2w(G))
print(bytes.fromhex(hex(discrete_log(P,G,G.order(),operation="+"))[_sage_const_2 :]))

